(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{294:function(s,e,n){"use strict";n.r(e);var a=n(13),t=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"reactive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactive"}},[s._v("#")]),s._v(" reactive")]),s._v(" "),e("p",[s._v("Vue3提供的reactive方法可将一个对象包装成一个proxy对象，从而实现对这个对象的依赖收集，reactive采用了一种懒代理的方式，当我们传给reactive的对象例如是这样的")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const reactiveData = reactive({\n\ta: 1,\n\tb: {\n\t\tc: 2\n\t}\n})\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("那我们在取reactiveData的时候我们会发现它是一个proxy，但是b却还不是一个proxy，但是当我们取reactiveData.b的时候，我们就发现它变成了一个proxy，这就是懒代理，与Vue2的处理方式有很大的不同，Vue2在一开始的时候，就利用递归将嵌套对象都用dineProperty转换了一遍，这样很耗性能。")]),s._v(" "),e("h2",{attrs:{id:"reactive代码片段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactive代码片段"}},[s._v("#")]),s._v(" reactive代码片段")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("import { isObject } from '@vue/shared';\nimport { mutableHandlers, ReactiveFlags } from './baseHandler';\n// 将数据转化成响应式的数据，只能做对象的代理\n// 因为同一个对象可以被多次代理，浪费性能，所以需要加一个缓存\nconst reactiveMap = new WeakMap(); // key只能是对象\n\n// 判断一个对象是否是reactive代理对象\nexport function isReactive(value) {\n  return !!(value && value[ReactiveFlags.IS_REACTIVE]);\n}\n\nexport function reactive(target: Record<string, any>) {\n  if (!isObject(target)) {\n    return;\n  }\n  if (target[ReactiveFlags.IS_REACTIVE]) {\n    // target[ReactiveFlags.IS_REACTIVE]这里会触发下面的get\n    return target;\n  }\n  /* 并没有重新定义属性，只是代理，在取值的时候会调用get\n   当赋值的时候会调用set\n  */\n  let exisitingProxy = reactiveMap.get(target);\n  if (exisitingProxy) {\n    return exisitingProxy;\n  }\n  /**\n * 有可能会出现这种写法\n *  const state1 = reactive(data);\n    const state2 = reactive(state1);\n    因此在代理之前需要判断有没有被代理过\n * */\n  //   第一次普通对象代理，我们会通过new Proxy代理一次\n  // 下一次你传递的是proxy，我们可以看一下她有没有代理过\n  //   如果访问这个proxy 有get方法的时候说明就访问过了\n\n  const proxy = new Proxy(target, mutableHandlers);\n  reactiveMap.set(target, proxy);\n  return proxy;\n}\n\n/** 上面的get之所以不用return target[key]，\n * 是因为可能会出现这种类型的代理数据\n * let target = {\n *      name: 'zf',\n *      get alias(){\n *          return this.name\n *      }\n * }\n * const proxy = new Proxy(target, {\n    get(target, key, receiver) {\n      return target[key];\n    },\n    set(target, key, value, receiver) {\n      target[key] = value;\n        return true;\n    },\n  });\n  \n    这样如果我要取值proxy[alias]，那么get只会执行一次，而不会执行两次\n    为何说要执行两次，因为alias里面还有获取当前上下文的name值，而如果用\n    target[key]这种方式取值的话，this.name的this指向的是target，target是\n    源对象并不是代理对象，自然不会重新走一次get\n*/\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br"),e("span",{staticClass:"line-number"},[s._v("42")]),e("br"),e("span",{staticClass:"line-number"},[s._v("43")]),e("br"),e("span",{staticClass:"line-number"},[s._v("44")]),e("br"),e("span",{staticClass:"line-number"},[s._v("45")]),e("br"),e("span",{staticClass:"line-number"},[s._v("46")]),e("br"),e("span",{staticClass:"line-number"},[s._v("47")]),e("br"),e("span",{staticClass:"line-number"},[s._v("48")]),e("br"),e("span",{staticClass:"line-number"},[s._v("49")]),e("br"),e("span",{staticClass:"line-number"},[s._v("50")]),e("br"),e("span",{staticClass:"line-number"},[s._v("51")]),e("br"),e("span",{staticClass:"line-number"},[s._v("52")]),e("br"),e("span",{staticClass:"line-number"},[s._v("53")]),e("br"),e("span",{staticClass:"line-number"},[s._v("54")]),e("br"),e("span",{staticClass:"line-number"},[s._v("55")]),e("br"),e("span",{staticClass:"line-number"},[s._v("56")]),e("br"),e("span",{staticClass:"line-number"},[s._v("57")]),e("br"),e("span",{staticClass:"line-number"},[s._v("58")]),e("br"),e("span",{staticClass:"line-number"},[s._v("59")]),e("br"),e("span",{staticClass:"line-number"},[s._v("60")]),e("br"),e("span",{staticClass:"line-number"},[s._v("61")]),e("br"),e("span",{staticClass:"line-number"},[s._v("62")]),e("br"),e("span",{staticClass:"line-number"},[s._v("63")]),e("br"),e("span",{staticClass:"line-number"},[s._v("64")]),e("br")])]),e("p",[s._v("PS：reative总共就做了这么几件事")]),s._v(" "),e("ol",[e("li",[s._v("判断是否为对象，如果不是对象的话就直接返回undefined；")]),s._v(" "),e("li",[s._v("Vue3为reactive对象提供了一个自定义的属性叫"),e("code",[s._v("__v_isReactive")]),s._v("，只有reactive对象才可以拿到 "),e("code",[s._v("__v_isReactive")]),s._v("属性，当我们对一个reactive对象再进行reactive的时候，那么会去判断对象里面有没有"),e("code",[s._v("__v_isReactive")]),s._v("，有的话直接返回reactive过的对象；")]),s._v(" "),e("li",[s._v("如果拿一个对象多次进行reative，那么它只会代理一次，后面直接从reactiveMap里面取缓存。")])]),s._v(" "),e("h2",{attrs:{id:"mutablehandlers代码片段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutablehandlers代码片段"}},[s._v("#")]),s._v(" mutableHandlers代码片段")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("import { isObject } from '@vue/shared';\nimport { activeEffect, track, trigger } from './effect';\nimport { reactive } from './reactive';\nexport enum ReactiveFlags {\n  IS_REACTIVE = '__v_isReactive',\n}\nexport const mutableHandlers = {\n  get(target: Record<string, any>, key: string | symbol, receiver: any) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return true;\n    }\n    // 我们需要把activeEffect和key关联在一起，就是说哪个属性对应的effect是谁\n    // 所以我们进行依赖收集\n    // 一个属性可以对应多个effect\n    /**\n     * effect(()=>{state.name})\n     * effect(()=>{state.name})\n     * 上面的name对应两个effect\n     * 一个对象上的某个属性可能对应多个effect\n     * 我们可以用一个weakmap结构，下面的name指的是属性，Set指的是effect\n     * WeakMap = {对象:Map{name:Set}}\n     */\n    track(target, 'get', key);\n    // 去代理对象上取值，就走get\n    // 这里可以监控到取值了\n    // return target[key]\n    // 有可能获取到的这个值还是对象，这个对象也要做代理\n    let res = Reflect.get(target, key, receiver);\n    if (isObject(res)) {\n      return reactive(res); //深度代理的实现，性能好，取值就可以进行代理，不取就不代理，vue2是一上来就递归代理，性能方面可想而知\n    }\n    return res as any;\n  },\n  set(\n    target: Record<string, any>,\n    key: string | symbol,\n    value: any,\n    receiver: any\n  ) {\n    // 去代理设置值，执行set\n    let oldValue = target[key as string];\n    let result = Reflect.set(target, key, value, receiver);\n    if (oldValue !== value) {\n      // 值变化了 要更新了\n      trigger(target, 'set', key, value, oldValue);\n    }\n    // 这里可以监控到设置值了\n    return result;\n  },\n};\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br"),e("span",{staticClass:"line-number"},[s._v("42")]),e("br"),e("span",{staticClass:"line-number"},[s._v("43")]),e("br"),e("span",{staticClass:"line-number"},[s._v("44")]),e("br"),e("span",{staticClass:"line-number"},[s._v("45")]),e("br"),e("span",{staticClass:"line-number"},[s._v("46")]),e("br"),e("span",{staticClass:"line-number"},[s._v("47")]),e("br"),e("span",{staticClass:"line-number"},[s._v("48")]),e("br"),e("span",{staticClass:"line-number"},[s._v("49")]),e("br"),e("span",{staticClass:"line-number"},[s._v("50")]),e("br")])]),e("p",[s._v("reactive之所以做成代理对象，那是因为需要用它来做依赖收集以及依赖的触发，当我们取值的时候进行依赖收集，当我们设置值的时候需要触发收集的依赖，并且把之前收集的依赖清除掉再重新收集。")])])}),[],!1,null,null,null);e.default=t.exports}}]);