# 事件循环

<img :src="$withBase('/browser/event-loop/20210621225806855.jpg')">

webapi是浏览器提供给我们的一些api，还有一个神秘的事件循环（Event Loop）和一个回调任务队列（Task Queue）

JavaScript是一门单线程的语言，单线程在运行时，意味着它只有一个调用栈，也就是上图的stack，同一时刻只能做一件事，我们先来看一个简单的案例，可以用可视化的方式理解一下这部分的知识
```
function multiply(a, b){
    return a * b;
}
function square(n) {
    return multiply(n, n);
}
function printSquare(n) {
    var squared = square(n);
    console.log(squared);
}
printSquare(4);
```
调用栈是一个数据结构，用于记录我们当前处在程序运行的哪个位置，如果调用了函数，就让它进栈，如果栈顶函数返回结果，就让它出栈，这个栈就是做函数的压入和弹出。我们运行这段代码，那么整段代码相当于一个main函数，所以我们把它压入栈中，下图就是整段代码的入栈出栈过程

<img :src="$withBase('/browser/event-loop/20210621231942720.png')">

如果你听说过栈溢出的话，这里有个例子
```
function foo() {
    return foo();
}
foo();
```
这摆明了就是一个套娃嘛

<img :src="$withBase('/browser/event-loop/20210621232813372.png')">

最后浏览器会问你，你该不会帧的要递归调用16000次foo吧？“Maximum call stack size excceeded”,我会先帮你终止进程，让你去检查代码。

我们先谈谈阻塞和阻塞的行为，实际上关于非阻塞并没有一个准确的定义，它只是一段执行速度很慢的代码。比如console.log就很快，但是做十亿次就很慢，图片请求很慢，网络请求也很慢，所以，阻塞其实指的就是栈中运行很慢的那些东西，比如这里有一段执行同步任务的伪代码。假设这里是jquery发起ajax请求，如果这是同步的会怎么样呢？让我们先忘记异步回调，假设这里是同步的
```
var foo = $.getSync("//foo.com");
var bar = $.getSync("//bar.com");
var qux = $.getSync("//qux.com");

console.log(foo);
console.log(bar);
console.log(qux);
```
在单线程编程语言中，我们无法像Ruby那样使用多线程，也就是说，在发出请求之后，必须一直等待，直到返回结果，除此之外并没有合适的处理方式，那么，问题何在呢？

我们用一个while循环来模拟上面这个过程，这里的while循环大概会持续一秒甚至五秒之后才能继续，在代码执行的过程中，页面的按钮，链接等等，点击都是无效的，被卡住了，除非请求完成，这个很明显不是我们想要的。如果我们想要给用户更好的体验，就不应该阻塞调用栈，那怎么处理这个问题呢？最简单的方法就是异步回调，使用异步回调之后，在浏览器或者node中几乎没有任何阻塞函数，它们都成了异步函数，我们运行代码，给它一个回调，稍后再回过头来执行。
```
console.log('hi');
setTimeout(function() {
    console.log('there);
}, 5000);
console.log('JSCONFEU');
```
那么将异步回调和此前聊过的调用栈联系起来，上面这段代码具体是怎么运行的呢？

<img :src="$withBase('/browser/event-loop/20210622233706691.png')">

<img :src="$withBase('/browser/event-loop/20210704223018531.png')">

代码运行执行console.log打印hi，接着我们看一下setTimeout的时候发生了什么？我们传递了一个回调函数参数和一个时间函数。注意setTimeout是浏览器提供给我们的api（运行JavaScript的环境提供给我们的），调用之后，浏览器给我们设置了一个定时器，之后浏览器会在一遍进行计时。setTimeout调用后已经成功设置了定时器，所以此时它可以出栈了，然后打印JSConfEU，调用栈清空。那么现在Webapi中就有一个定时器，计时五秒后结束，而Webapi是不能无缘无故改动你的代码的，它不能冒然进入调用栈中，否则就会像是随机出现在你的代码中一样。因此这里引入了任务队列或者回调任务队列。一般在Webapi结束之后（计时结束、请求得到响应等）会把回调函数送到任务队列中。然后，我们的重点--事件循环，终于出现了。事件循环实际上就像是这一整个过程中最简单的那个部分。事件循环做的事情很简单，就是查看栈和任务队列，如果栈空，那么就把任务队列队头的任务压入栈中，之后这个任务得到执行。

现在可以看到，console.log('JSCONFEU');执行完之后栈是空的，任务队列中还有一个回调函数。线程说：“我得做点什么了”，于是它把回调函数压入栈中，调用栈是Javascript管辖的地盘，所以接下来就是v8的工作了。所以，回调函数进入栈中并执行，打印there！！！

接下来我们来看一个不一样的案例，这很可能是你初学异步时感到困惑的地方，把上面的定时器5000改为0，既然如此，我何必要像之前那样把回调函数放在setTimeout里面呢？直接执行不香吗？其实这么做的目的是，让回调在调用栈清空后再来执行，改为0之后，运行输出的代码还是一样的。因为执行到定时器的时候，马上计时完成并被送到队列中。因为事件循环必须等到栈清空之后，才能讲任务队列中的任务压入栈中。

接下来我们看这段代码
```
// # 1
console.log('started);
// # 2
$.on('button','click',function onClick(){
    // # 3
    console.log('Clicked');
});
// # 4
setTimeout(function onTimeout(){
    // # 5
    console.log('Timeout');
},5000);
// # 6
console.log('Done);
```
图我就先不画了，太累人。这段代码会先把1放入执行栈，执行完后把2放入调用栈，发现2是个webapi，所以放到webapi的框框里面，接着把4放入执行栈，发现4也是一个webapi，所以放入webapi的框框里面，接着把6放入执行栈，5秒钟到了之后，把5放入任务队列，然后发现执行栈空了，把5放入执行栈执行，接着发现用户触发点击事件，把3放入任务队列，同样也是发现执行栈空了，所以把3放入执行栈执行，至此所有流程执行完毕。

接着再来看一段代码，这段代码可以看出些许同步程序和异步程序的运行时间差别
```
// 同步调用
// # 1
[1,2,3,4].forEach(function(i){
    // # 2
    console.log(i);
})
// 异步调用
// # 3
function asyncForEach(array,cb){
    // # 4 
    array.forEach(function(){
        // # 5
        setTimeout(cb,0);
    })
}
// # 6
asyncForEach([1,2,3,4],function(i){
    // # 7
    console.log(i)
})
```
首先把1放入执行栈，然后四个2陆续放入执行栈，执行完之后，6放入执行栈，4放入执行栈，然后陆续四个5放入执行栈，发现是webapi，就放入webapi的框框里，然后再陆续把四个回调7放进任务队列，最后陆陆续续放进执行栈。这个例子其实异步化的有点并不是很明显，因为都是毫秒级别的程序，但是假设，数组里面是一个很耗时的操作，异步化的有点就显而易见了。

浏览器每16.6毫秒会针对页面进行一次重绘，这种尽可能的重绘使得页面保持在每秒60帧，但是重绘过程是收到JavaScript影响的，在执行栈未清空的时候，是无法进行重绘的。和前面说到的一样，webapi的回调需要等到执行栈为空的时候才能执行，不同的是，渲染的优先级高于之前所说的回调。一般来说，每16ms它就会进入一次队列，并等到栈清空后真正进行渲染。每16.6毫秒都在询问是否可以渲染，由于栈是空的，所以都得到了肯定的答复，但是上面的代码如果变成下面这样
```
// 同步调用
// # 1
[1,2,3,4].forEach(function(i){
    // # 2
    delay();
})
// 异步调用
// # 3
function asyncForEach(array,cb){
    // # 4 
    array.forEach(function(){
        // # 5
        setTimeout(cb,0);
    })
}
// # 6
asyncForEach([1,2,3,4],function(i){
    // # 7
    delay();
})
```
delay()是一个非常耗时的同步任务，那么在同步调用里面，这个费时的操作将阻塞渲染过程，一旦被阻塞渲染，就意味着我们不能选中文本，不能进行点击，不能得到响应。在异步的代码里面，虽然在执行的时候也有些许阻塞，但是相比于同步的代码，已经快了很多了。在一个回调出栈，另一个回调进栈的间隙（此时栈为空），渲染得以顺利进行。