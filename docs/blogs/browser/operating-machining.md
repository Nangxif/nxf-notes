# 浏览器运行机制

## 一、浏览器的结构

<img :src="$withBase('/browser/operating-machining/1.png')" data-fancybox="gallery">

## 二、进程和线程
当我们启动某个程序时，就会创建一个进程来执行任务代码，同时为该进程分配内存空间，该应用的所有状态都保存在内存空间里，当应用关闭时，该内存空间就会被回收。进程可以启动更多的线程来执行任务，由于每个进程分配的空间是独立的，如果两个进程之间需要传递某些数据，则需要通过进程间通信管道IPC来传递。很多应用都是多进程的结构，这样是为了避免某个进程卡死，由于进程之间相互独立，这样不会影响到整个应用程序。

浏览器就是多进程的，我们根据进程功能的不同来拆卸浏览器

1. 浏览器进程：负责控制除标签页外的用户界面，包括控制chrome的地址栏，书签栏，返回和前进按钮，同时提供存储功能
2. 缓存进程
3. 网络进程：负责发起接受网络请求
4. GPU进程：负责整个浏览器界面的渲染，用于3D绘制
5. 插件进程：负责控制网站使用的所有插件，比如flash。每种插件一个进程，插件运行时才会创建
6. 渲染器进程：用来控制显示tab标签内的所有内容，浏览器在默认情况下会为每个标签页都创建一个进程。负责界面渲染，脚本执行，事件处理等

## 三、从浏览器输入网址，到页面渲染到底经过了什么？
当网络线程获取到数据后，会通过SafeBrowsing（谷歌的一套站点安全系统）来检查站点是否恶意网站，如果是，则会展示一个警告页面，浏览器会阻止你的访问。当返回数据准备完毕并通过安全校验时，网络进程会通知UI线程可以工作了。UI线程会创建一个渲染器进程（Renderer Thread）来渲染页面。浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程（Renderer Process）,渲染器进程接受到的数据是html。渲染器进程的核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造dom数据结构。

html首先经过Tokenizer标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在dom树构造过程中会创建document对象，然后以document为根节点的DOM树不断进行修改，向其中添加各种元素。HTML代码中往往会引入一些额外的资源，比如图片，css，js脚本等等，图片和css这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞HTML的解析，因为他们不会影响DOM的生成。但当HTML解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并执行js，js会阻塞渲染这是因为浏览器并不知道js执行是否会改变当前的HTML结构，如果js代码里用了document.write方法来修改HTML，那之前的HTML解析就没有任何意义了，这也是我们为什么一直说要把js脚本放在合适的位置引入，或者使用async或defer属性来异步加载执行js。

<img :src="$withBase('/browser/operating-machining/2.png')" data-fancybox="gallery">

在HTML解析完成后，我们就会获得一个DOM Tree，但是我们还不知道DOM Tree上面每个节点应该长什么样子，主线程需要解析CSS，确定每个DOM节点的计算样式，即使你没有提供自定义的CSS样式，浏览器也会有自己默认的样式表，比如标签h1，h2会有自己的默认样式。知道DOM结构和每个节点的样式后，我们接下来需要知道每个节点放在页面上的哪个位置，也就是该节点的坐标以及该节点需要占用多大的区域，这个阶段被成为layout布局，主线程通过DOM和计算好的样式来生成Layout tree，Layout tree上的每个节点都记录了x，y坐标和边框尺寸。这里需要注意的一点是，DOM tree和Layout tree并不是一一对应的，设置了display:none的节点不会出现在Layout tree上，而在before等伪类中添加了content值的元素，content里的内容会出现在Layout tree上，不会出现在DOM tree里，这是因为DOM树是通过HTML解析获得，并不关心样式，而Layout tree是根据DOM和计算好的样式来生成，Layout tree和最后显示在页面上的节点是一一对应的。我们在知道了节点的大小，形状和位置之后，这还不够，还需要知道以什么样的顺序绘制（paint）。z-index会影响节点绘制的层级关系如果我们按照dom的层级结构来绘制界面，则会导致错误渲染，为了保证在屏幕上展示正确的层级，主线程遍历Layout tree创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段被称为绘制（paint）。现在知道了文档的绘制顺序，就需要把这些信息转化成像素点了，显示在屏幕上，这种行为被成为栅格化（Rastering）。Chrome最早使用了一种很简单的方式 ，只栅格化可视区的（Viewport）的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式带来的问题显而易见，会导致展示延迟。随着不断的优化升级，现在的Chrome采用了一种更为复杂的栅格化流程，叫做合成（Composting），合成是一种将页面的各个部分分成多个图层，分别对其进行栅格化并在合成器线程中单独进行合成页面的技术。简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。

详细地说就是：主线程遍历Layout tree生成Layer（图层）tree，当Layer tree生成完毕和绘制顺序确定之后，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化。由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块（tiles），然后将每个图块发送给栅格化线程（Raster Thread），栅格线程栅格化每个图块，并将他们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集称为“draw quads”的图块信息，这些信息里记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，根据这些信息合成器线程生成了一个合成器帧，然后整个合成器帧通过IPC发送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上，这时候终于能看到页面内容了。当页面发生变化，比如滚动了当前页面，都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上。

整理一下上面所讲的东西：浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程，主线程将HTML解析构造DOM树，然后进行样式计算，根据DOM树和生成好的样式生成Layout tree，通过遍历Layout tree生成绘制顺序表，接着遍历Layout tree生成了Layer tree，然后主线程将Layer tree和绘制顺序信息一起传给合成器线程，合成器线程按照规则进行分图层，并把图层分为更小的图块（tiles）传给栅格线程进行栅格化，栅格化完成后，合成器线程会获得栅格线程传过来的“draw quads”图块信息，根据这些信息合成器线程上合成了一个合成器帧，然后将该合成器帧通过IPC传递给浏览器进程，浏览器进程再传到GPU进行渲染，之后就展示到屏幕上了。

<img :src="$withBase('/browser/operating-machining/3.png')" data-fancybox="gallery">

当我们改变一个元素的尺寸位置属性时，会重新进行样式计算（Computed Style），布局（Layout）绘制（Paint）以及后面的所有流程，这种行为我们成为重排列。

当我们改变某个元素的颜色属性时，不会重新触发布局，但还是会触发计算样式和绘制，这个就是重绘。

重排和重绘都会占用主线程。还有另外一个东西也是运行在主线上的，就是js，既然他们都在主线程运行，那么就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。

我们知道当页面以每秒60帧的刷新率时，才不会让用户感觉到页面卡顿，如果在运行动画时还有大量的js任务需要执行，因为布局，绘制和js执行都是在主线程运行的，当在一帧的时间内布局和绘制结束之后，还有剩余时间，js就会拿到主线程的使用权，如果js执行时间过长，就会导致在下一帧开始时js没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿。有什么优化的手段嘛？

有！第一种就是用requestAnimationFrame这个api，这个方法会在每一帧被调用，通过api的回调，然后我们可以把js运行任务分成一些更小的任务块（分到每一帧），在每一帧时间用完只花钱暂停js执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时布局和绘制。

第二种优化方法，通过刚才的流程图我们知道栅格化的整个流程是不占用主线程的，只在合成器线程和栅格进程中运行，这就以为着它无需跟js抢夺主线程，我们刚才提到如果反复进行重绘和重排可能会导致掉帧，这是因为有可能js执行阻塞了主线程，而CSS中有个动画属性叫transform，通过这个属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程，所以不会收到主线程中js执行的影响。更重要的是通过tarnsform实现的动画不需要经过布局绘制样式计算等操作，所以节省了很多运算时间。



​